---
layout: default
title: Home
permalink: /
---

---
# leave this front matter so Pages renders Markdown with the theme
---

# Computer Science ePortfolio

Welcome! This portfolio presents my professional self-assessment and three enhanced artifacts aligned to **software design & engineering**, **algorithms & data structures**, and **databases**. Use the quick links below to jump around.

- [Professional Self-Assessment](#professional-self-assessment)
- [Artifacts](#artifacts)
  - [Software Design & Engineering](#artifact-1-software-design--engineering)
  - [Algorithms & Data Structures](#artifact-2-algorithms--data-structures)
  - [Databases](#artifact-3-databases)
- [Code Review Video](#code-review-video)
- [Submission Checklist](#submission-checklist)

---

## Professional Self-Assessment

**Who I Am as a Developer**  
I’m a full-stack–leaning developer who enjoys turning messy ideas into clean, working software. Over the last two years, I moved from basic console programs to structured, testable projects with clear user flows and maintainable code. Coursework, labs, and iterative debugging built a strong foundation in Python, C++, JavaScript, and SQL. That mix lets me pick the right tool for the job and keep the focus on making the experience simple for the person using it.

**How the Program Shaped My Practice**  
Team labs and code reviews taught me to communicate with both technical peers and non-technical audiences. I’m comfortable explaining algorithm choices, data structures, and impacts on performance in plain language, then switching to code-level details when needed. Design choices reflect a security mindset: parameterized queries, sanitized inputs, and separation of concerns reduce risk without adding friction. These habits carry across everything—from console tools to web projects.

Data structures and algorithms show up in practical ways. Sorting and search features improve usability. Histogram outputs and reports provide quick visibility into patterns. When trade-offs appear, I aim for clear, visible logic first, then optimize once behavior is correct and tested. This approach keeps projects moving and avoids wasted time chasing premature micro-optimizations.

**How the Artifacts Fit Together**  
The three artifacts are different views of the same project at increasing maturity. The software design piece demonstrates language portability and cleaner architecture. The algorithms and data structures piece adds user-facing value with sorting and search features that people actually use. The database piece introduces persistence and a simple schema so results stick between sessions. Together, they show growth from a single-file utility into a small, maintainable application with clear responsibilities and room to expand.

Going forward, I’m targeting roles where I can keep improving frontend polish while staying confident in backend logic and data safety. The work here reflects the habits I’ll bring to a team: readable code, thoughtful structure, and features that make sense to real users. It also maps to program outcomes on collaboration, communication, problem-solving with sound practices, modern tools, and secure design choices.

---

## Artifacts

### Artifact 1: Software Design & Engineering

**Artifact links**
- Original code: **TODO: add link**
- Enhanced code: **TODO: add link**
- Optional demo/screenshot: **TODO: add link**

**A. Description**  
Briefly describe the artifact. What is it and when was it created? Mention the original purpose and the course context. Keep this to 4–6 sentences with concrete details.

**B. Justification**  
Explain why you selected this item for the ePortfolio and the specific components that showcase your skills. Call out what changed during the enhancement and which skills were demonstrated (e.g., modularization, input validation, improved architecture, better error handling). Tie those changes to the course outcomes you met.

**C. Reflection**  
Reflect on how your process evolved during the enhancement. Describe 1–2 challenges, how feedback shaped the final result, and what you learned. Name the outcomes that were fully or partially met and be honest about any that were not. End with how this positions you for the work you want next.

**Quick Outcome Mapping**
- Outcome 1 (Collaboration): Clear structure, comments, separation of concerns make handoffs easier.  
- Outcome 2 (Communication): Professional documentation and consistent prompts/outputs.  
- Outcome 3 (Algorithmic Practice): Intentional data structures and trade-off decisions.  
- Outcome 4 (Techniques & Tools): Modern patterns and pragmatic feature work that adds value.  
- Outcome 5 (Security): Validated inputs, safe I/O.

---

### Artifact 2: Algorithms & Data Structures

**Artifact links**
- Original code: **TODO: add link**
- Enhanced code: **TODO: add link**
- Optional demo/screenshot: **TODO: add link**

**A. Description**  
What it is, when built, and the original scope. 4–6 sentences.

**B. Justification**  
Why it belongs here and which parts prove your skills. Call out algorithmic choices (e.g., sorting by frequency/alphabetical, search), complexity considerations, and tests. Map to outcomes met.

**C. Reflection**  
What you learned, challenges you hit, feedback you applied, improvements achieved, outcomes met/not met, and next steps.

**Quick Outcome Mapping**
- Outcome 1: Code clarity supports reviews and collaboration.  
- Outcome 2: Communicated algorithm trade-offs clearly.  
- Outcome 3: Applied DS&A to improve performance/utility.  
- Outcome 4: Used appropriate libraries/tooling for testing.  
- Outcome 5: Input validation and safe handling of edge cases.

---

### Artifact 3: Databases

**Artifact links**
- Original code: **TODO: add link**
- Enhanced code: **TODO: add link**
- Optional demo/screenshot: **TODO: add link**

**A. Description**  
Brief overview (what, when, and original purpose). 4–6 sentences.

**B. Justification**  
What you added/changed (e.g., SQLite/MySQL integration, schema design, parameterized queries, persistence layer, simple CRUD). Why these changes matter and which outcomes they demonstrate.

**C. Reflection**  
What you learned integrating a DB (migrations, schema choices, query safety, error handling), any feedback incorporated, outcomes met/not met, and future improvements.

**Quick Outcome Mapping**
- Outcome 1: Separation of concerns simplifies team collaboration.  
- Outcome 2: Clear schema and docs help stakeholders.  
- Outcome 3: Efficient queries and indexes where appropriate.  
- Outcome 4: Practical data tooling and migration habits.  
- Outcome 5: Parameterized queries, least privilege, sanitized input.
